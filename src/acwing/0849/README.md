<!--
 * @Author: shaqsnake
 * @Email: shaqsnake@gmail.com
 * @Date: 2019-09-16 15:58:00
 * @LastEditTime: 2019-10-17 10:25:28
 * @Description: Acwing 849
 -->

# 849. Dijkstra求最短路 I

## 题目

给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。

#### 输入格式

第一行包含整数n和m。

接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。

#### 输出格式

输出一个整数，表示1号点到n号点的最短距离。

如果路径不存在，则输出-1。

#### 数据范围

![](http://latex.codecogs.com/gif.latex?\\1%20\leq%20n%20\leq%20500),

![](http://latex.codecogs.com/gif.latex?\\1%20\leq%20m%20\leq%2010^5),

图中涉及边长均不超过10000。

#### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

#### 输出样例：

```
3
```

## 题解

### Dijkstra

首先根据题意来决定用哪一种最短路算法，此题是一个单源图的最短路问题，且图中不包括负权边，所以考虑使用Dijkstra算法。

Dijkstra算法的过程如下：

1. 定义一个数组d[1..n]来记录从起点1到n个点的最短距离，所以最初d的状态为 d[1] = 0, d[2..n] = INF;
2. 开始循环n次，每次循环：
    
    a. 从当前还未确定最短距离的点中找出一个权重最小的点，即从起点到剩余点中距离最短的那个点；
    b. 把选出的点加入到已选择的集合中，保证以后的循环不再重复选择此点；
    c. 用当前点的状态去更新剩下未选择点的状态即距离，比如选择点为t，要更新的点为j，更新时用最短的距离更新j的状态，即 d[j] = min(d[j], d[t] + w[t][j]);

3. 循环结束后，d[n]记录的就是从起点1到终点n的最短距离，如果此时状态还是初始的INF，说明从起点没有路径可到达终点。

注：此题的数据范围表示边的个数m远大于点的个数n，所以时一个稠密图（边数多），需要用邻接矩阵来存储所有边的权重，如果时一个稀疏图（边数和点数相差不大），可以用邻接表来存储。
