<!--
 * @Author: shaqsnake
 * @Email: shaqsnake@gmail.com
 * @Date: 2019-09-16 15:58:00
 * @LastEditTime: 2019-10-22 11:46:57
 * @Description: Acwing 895
 -->

# 895. 最长上升子序列

## 题目

给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。

#### 输入格式

第一行包含两个整数N和M。

第二行包含一个长度为N的字符串，表示字符串A。

第三行包含一个长度为M的字符串，表示字符串B。

字符串均由小写字母构成。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

![](http://latex.codecogs.com/gif.latex?\\1%20\leq%20N%20\leq%201000)


#### 输入样例：

```
4 5
acbd
abedc
```

#### 输出样例：

```
4
```

## 题解

### DP

用一个二维数组f[1..n][1..m]来表示最长公共子序列的状态，其中f[i][j]表示以a[i]和b[j]结尾的最长公共子序列长度，此时f[i][j]的状态可以由四种状态转移过来：

1. a[i]和b[j]都不能组成更长的公共子序列，此时状态可由f[i-1][j-1]推导出；
2. a[i]可以组成更长的公共子序列而b[j]不能，此时状态可由f[i][j-1]推导出；
3. b[j]可以组成更长的公共子序列而a[i]不能，此时状态可由f[i-1][j]推导出；
4. a[i]和b[j]相等可以组成更长的公共子序列，此时状态等于f[i-1][j-1] + 1。

将上述的四种状态优化后可得状态转移方程为：

```c++
f[i][j] = max(f[i-1][j], f[i][j-1]) if a[i] != b[j];
f[i][j] = max(f[i][j], f[i-1][j-1] + 1) if a[i] == b[j];
```