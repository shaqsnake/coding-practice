# 6. 多重背包问题 III

## 题目

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，V (0<N≤1000, 0<V≤20000)，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N≤1000

0<V≤20000

0<vi,wi,si≤20000

#### 提示：

本题考查多重背包的单调队列优化方法。

#### 输入样例：

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```

## 题解

### DP

此题同[5. 多重背包问题 II](https://github.com/shaqsnake/coding-practice/blob/master/src/acwing/0005/)一样，也是在[4. 多重背包问题 I](https://github.com/shaqsnake/coding-practice/blob/master/src/acwing/0004/)的基础上增大了数据范围，所以要通过优化的方法来计算。

首先列出状态f[i][j]的经典转移方程为：
```
f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v] + 2w, f[i-1][j-3v] + 3w, ... f[i-1][j-sv] + sw)
```
把此方程推广到f[i][j-v], f[i][j-2v], f[i][j-3v]...可得：
```
f[i][j] = max(f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v] + 2w, f[i-1][j-3v] + 3w, ... f[i-1][j-sv] + sw)
f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v] + w, f[i-1][j-3v] + 2w, f[i-1][j-4v] + 3w, ... f[i-1][j-(s+1)v] + sw)
f[i][j-2v] = max(f[i-1][j-2v], f[i-1][j-3v] + w, f[i-1][j-4v] + 2w, f[i-1][j-5v] + 3w, ... f[i-1][j-(s+2)v] + sw)
f[i][j-3v] = max(f[i-1][j-3v], f[i-1][j-4v] + w, f[i-1][j-5v] + 2w, f[i-1][j-6v] + 3w, ... f[i-1][j-(s+3)v] + sw)
...
f[i][j-sv] = max(f[i-1][j-sv], f[i-1][j-(s+1)v] + w, f[i-1][j-(s+2)v] + 2w, f[i-1][j-(s+3)v] + 3w, ... f[i-1][j-(s+s)v] + sw)
```
从上面的等式中可以发现(f[i][j], f[i][j-v], f[i][j-2v], f[i][j-3v], ...)中有部分表达是重合的，只是之间相差了w，这时我们把(j, j-v, j-2v, j-3v, ...)用j % v的值r来表示，即j = r + sv且逆序为(r, r+v, r+2v, ... r+(s-1)v, j)将上面的等式再次转换：
```
f[i][r]    = max(f[i-1][r])
f[i][r+v]  = max(f[i-1][r] +  w, f[i-1][r+v])
f[i][r+2v] = max(f[i-1][r] + 2w, f[i-1][r+v] + w, f[i-1][r+2v])
...
f[i][r+kv] = max(f[i-1][r] + kw, f[i-1][r+v] + w, ... f[i-1][r+kv])
...
f[i][j]    = max(f[i-1][j-sv] + sw, ... f[i-1][j-2v] + 2w, f[i-1][j-v] + w, f[i-1][j]) = max(f[i-1][r] + sw, ... f[i-1][r+(s-2)v] + 2w, f[i-1][r+(s-1)v] + w, f[i-1][r+sv]])
```
由上面等式可以找出(r, r+v, r+2v, ... r+(s-1)v, j)序列中的规律是r+kv的状态可以由(r, r+v, r+2v, ... r+(k-1)v)推导而来，而且每个状态之间有w的偏移量。这样可以利用一个单调队列在一个滑动窗口中把最大的状态找到。

遍历所有的r值（0..v)，依次将r+kv状态放入单调队列q，q中保存的就是前s个物品最大的值，然后根据队头元素的值q[h]来更新状态
```
f[i][u] = max(f[i][u], f[i-1][q[h]] + (u - q[h])/v * w)
```

最后，此题因为第i层的状态只由i-1层推导而来，所以可以状态可以优化成一维数组。